{"code":"import { Hash, LockingScript, OP, TransactionSignature, UnlockingScript, Utils, } from \"@bsv/sdk\";\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class CosignTemplate {\n    /**\n     * Creates a P2PKH locking script for a given public key hash or address string\n     *\n     * @param {number[] | string} userPKHash or address - An array or address representing the public key hash of the owning user.\n     * @param {PublicKey} approverPubKey - Public key of the approver.\n     * @returns {LockingScript} - A P2PKH locking script.\n     */\n    lock(userPKHash, approverPubKey) {\n        let pkhash = [];\n        if (typeof userPKHash === \"string\") {\n            const hash = Utils.fromBase58Check(userPKHash);\n            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f)\n                throw new Error(\"only P2PKH is supported\");\n            pkhash = hash.data;\n        }\n        else {\n            pkhash = userPKHash;\n        }\n        const lockingScript = new LockingScript();\n        lockingScript\n            .writeOpCode(OP.OP_DUP)\n            .writeOpCode(OP.OP_HASH160)\n            .writeBin(pkhash)\n            .writeOpCode(OP.OP_EQUALVERIFY)\n            .writeOpCode(OP.OP_CHECKSIGVERIFY)\n            .writeBin(approverPubKey.encode(true))\n            .writeOpCode(OP.OP_CHECKSIG);\n        return lockingScript;\n    }\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} userPrivateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    userUnlock(userPrivateKey, signOutputs = \"all\", anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = TransactionSignature.SIGHASH_FORKID;\n                if (signOutputs === \"all\") {\n                    signatureScope |= TransactionSignature.SIGHASH_ALL;\n                }\n                if (signOutputs === \"none\") {\n                    signatureScope |= TransactionSignature.SIGHASH_NONE;\n                }\n                if (signOutputs === \"single\") {\n                    signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID\n                    ? input.sourceTXID\n                    : input.sourceTransaction?.id(\"hex\");\n                if (!sourceTXID) {\n                    throw new Error(\"The input sourceTXID or sourceTransaction is required for transaction signing.\");\n                }\n                sourceSatoshis ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n                if (!sourceSatoshis) {\n                    throw new Error(\"The sourceSatoshis or input sourceTransaction is required for transaction signing.\");\n                }\n                lockingScript ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        .lockingScript;\n                if (!lockingScript) {\n                    throw new Error(\"The lockingScript or input sourceTransaction is required for transaction signing.\");\n                }\n                const preimage = TransactionSignature.format({\n                    sourceTXID,\n                    sourceOutputIndex: input.sourceOutputIndex,\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence || 0xffffffff,\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope,\n                });\n                const rawSignature = userPrivateKey.sign(Hash.sha256(preimage));\n                const sig = new TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);\n                const unlockScript = new UnlockingScript();\n                unlockScript.writeBin(sig.toChecksigFormat());\n                unlockScript.writeBin(userPrivateKey.toPublicKey().encode(true));\n                return unlockScript;\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73) + approver signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 182;\n            },\n        };\n    }\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} approverPrivateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(approverPrivateKey, userSigScript, signOutputs = \"all\", anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = TransactionSignature.SIGHASH_FORKID;\n                if (signOutputs === \"all\") {\n                    signatureScope |= TransactionSignature.SIGHASH_ALL;\n                }\n                if (signOutputs === \"none\") {\n                    signatureScope |= TransactionSignature.SIGHASH_NONE;\n                }\n                if (signOutputs === \"single\") {\n                    signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID\n                    ? input.sourceTXID\n                    : input.sourceTransaction?.id(\"hex\");\n                if (!sourceTXID) {\n                    throw new Error(\"The input sourceTXID or sourceTransaction is required for transaction signing.\");\n                }\n                sourceSatoshis ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n                if (!sourceSatoshis) {\n                    throw new Error(\"The sourceSatoshis or input sourceTransaction is required for transaction signing.\");\n                }\n                lockingScript ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        .lockingScript;\n                if (!lockingScript) {\n                    throw new Error(\"The lockingScript or input sourceTransaction is required for transaction signing.\");\n                }\n                const preimage = TransactionSignature.format({\n                    sourceTXID,\n                    sourceOutputIndex: input.sourceOutputIndex,\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence || 0xffffffff,\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope,\n                });\n                const rawSignature = approverPrivateKey.sign(Hash.sha256(preimage));\n                const sig = new TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);\n                const unlockScript = new UnlockingScript();\n                unlockScript.writeBin(sig.toChecksigFormat());\n                unlockScript.writeScript(userSigScript);\n                return unlockScript;\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73) + approver signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 182;\n            },\n        };\n    }\n}\n//# sourceMappingURL=mneeCosignTemplate.js.map","references":["/Users/danwagner/Desktop/Code/mnee-ops/node_modules/@bsv/sdk/dist/types/mod.d.ts"],"map":"{\"version\":3,\"file\":\"mneeCosignTemplate.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/mneeCosignTemplate.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/danwagner/Desktop/Code/mnee-ops/dist/mneeCosignTemplate.d.ts","writeByteOrderMark":false,"text":"import { LockingScript, type PrivateKey, type PublicKey, type Script, type ScriptTemplate, type Transaction, UnlockingScript } from \"@bsv/sdk\";\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class CosignTemplate implements ScriptTemplate {\n    /**\n     * Creates a P2PKH locking script for a given public key hash or address string\n     *\n     * @param {number[] | string} userPKHash or address - An array or address representing the public key hash of the owning user.\n     * @param {PublicKey} approverPubKey - Public key of the approver.\n     * @returns {LockingScript} - A P2PKH locking script.\n     */\n    lock(userPKHash: string | number[], approverPubKey: PublicKey): LockingScript;\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} userPrivateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    userUnlock(userPrivateKey: PrivateKey, signOutputs?: \"all\" | \"none\" | \"single\", anyoneCanPay?: boolean, sourceSatoshis?: number, lockingScript?: Script): {\n        sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n        estimateLength: () => Promise<182>;\n    };\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} approverPrivateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(approverPrivateKey: PrivateKey, userSigScript: Script, signOutputs?: \"all\" | \"none\" | \"single\", anyoneCanPay?: boolean, sourceSatoshis?: number, lockingScript?: Script): {\n        sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n        estimateLength: () => Promise<182>;\n    };\n}\n"}}
