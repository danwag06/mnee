{"version":3,"file":"index.modern.js","sources":["../src/mneeCosignTemplate.ts","../src/mneeService.ts","../src/utils/helper.ts","../src/index.ts"],"sourcesContent":["import {\n  Hash,\n  LockingScript,\n  OP,\n  type PrivateKey,\n  type PublicKey,\n  type Script,\n  type ScriptTemplate,\n  type Transaction,\n  TransactionSignature,\n  UnlockingScript,\n  Utils,\n} from \"@bsv/sdk\";\n\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class CosignTemplate implements ScriptTemplate {\n  /**\n   * Creates a P2PKH locking script for a given public key hash or address string\n   *\n   * @param {number[] | string} userPKHash or address - An array or address representing the public key hash of the owning user.\n   * @param {PublicKey} approverPubKey - Public key of the approver.\n   * @returns {LockingScript} - A P2PKH locking script.\n   */\n  lock(\n    userPKHash: string | number[],\n    approverPubKey: PublicKey\n  ): LockingScript {\n    let pkhash: number[] = [];\n    if (typeof userPKHash === \"string\") {\n      const hash = Utils.fromBase58Check(userPKHash);\n      if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f)\n        throw new Error(\"only P2PKH is supported\");\n      pkhash = hash.data as number[];\n    } else {\n      pkhash = userPKHash;\n    }\n    const lockingScript = new LockingScript();\n    lockingScript\n      .writeOpCode(OP.OP_DUP)\n      .writeOpCode(OP.OP_HASH160)\n      .writeBin(pkhash)\n      .writeOpCode(OP.OP_EQUALVERIFY)\n      .writeOpCode(OP.OP_CHECKSIGVERIFY)\n      .writeBin(approverPubKey.encode(true) as number[])\n      .writeOpCode(OP.OP_CHECKSIG);\n\n    return lockingScript;\n  }\n\n  /**\n   * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n   *\n   * The returned object contains:\n   * 1. `sign` - A function that, when invoked with a transaction and an input index,\n   *    produces an unlocking script suitable for a P2PKH locked output.\n   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n   *\n   * @param {PrivateKey} userPrivateKey - The private key used for signing the transaction.\n   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n   * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n   * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n   */\n  userUnlock(\n    userPrivateKey: PrivateKey,\n    signOutputs: \"all\" | \"none\" | \"single\" = \"all\",\n    anyoneCanPay = false,\n    sourceSatoshis?: number,\n    lockingScript?: Script\n  ): {\n    sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n    estimateLength: () => Promise<182>;\n  } {\n    return {\n      sign: async (tx: Transaction, inputIndex: number) => {\n        let signatureScope = TransactionSignature.SIGHASH_FORKID;\n        if (signOutputs === \"all\") {\n          signatureScope |= TransactionSignature.SIGHASH_ALL;\n        }\n        if (signOutputs === \"none\") {\n          signatureScope |= TransactionSignature.SIGHASH_NONE;\n        }\n        if (signOutputs === \"single\") {\n          signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n        }\n        if (anyoneCanPay) {\n          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n        }\n\n        const input = tx.inputs[inputIndex];\n\n        const otherInputs = tx.inputs.filter(\n          (_, index) => index !== inputIndex\n        );\n\n        const sourceTXID = input.sourceTXID\n          ? input.sourceTXID\n          : input.sourceTransaction?.id(\"hex\");\n        if (!sourceTXID) {\n          throw new Error(\n            \"The input sourceTXID or sourceTransaction is required for transaction signing.\"\n          );\n        }\n        sourceSatoshis ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n        if (!sourceSatoshis) {\n          throw new Error(\n            \"The sourceSatoshis or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n        lockingScript ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex]\n            .lockingScript;\n        if (!lockingScript) {\n          throw new Error(\n            \"The lockingScript or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n\n        const preimage = TransactionSignature.format({\n          sourceTXID,\n          sourceOutputIndex: input.sourceOutputIndex,\n          sourceSatoshis,\n          transactionVersion: tx.version,\n          otherInputs,\n          inputIndex,\n          outputs: tx.outputs,\n          inputSequence: input.sequence || 0xffffffff,\n          subscript: lockingScript,\n          lockTime: tx.lockTime,\n          scope: signatureScope,\n        });\n        const rawSignature = userPrivateKey.sign(Hash.sha256(preimage));\n        const sig = new TransactionSignature(\n          rawSignature.r,\n          rawSignature.s,\n          signatureScope\n        );\n        const unlockScript = new UnlockingScript();\n        unlockScript.writeBin(sig.toChecksigFormat());\n        unlockScript.writeBin(\n          userPrivateKey.toPublicKey().encode(true) as number[]\n        );\n        return unlockScript;\n      },\n      estimateLength: async () => {\n        // public key (1+33) + signature (1+73) + approver signature (1+73)\n        // Note: We add 1 to each element's length because of the associated OP_PUSH\n        return 182;\n      },\n    };\n  }\n\n  /**\n   * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n   *\n   * The returned object contains:\n   * 1. `sign` - A function that, when invoked with a transaction and an input index,\n   *    produces an unlocking script suitable for a P2PKH locked output.\n   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n   *\n   * @param {PrivateKey} approverPrivateKey - The private key used for signing the transaction.\n   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n   * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n   * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n   */\n  unlock(\n    approverPrivateKey: PrivateKey,\n    userSigScript: Script,\n    signOutputs: \"all\" | \"none\" | \"single\" = \"all\",\n    anyoneCanPay = false,\n    sourceSatoshis?: number,\n    lockingScript?: Script\n  ): {\n    sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n    estimateLength: () => Promise<182>;\n  } {\n    return {\n      sign: async (tx: Transaction, inputIndex: number) => {\n        let signatureScope = TransactionSignature.SIGHASH_FORKID;\n        if (signOutputs === \"all\") {\n          signatureScope |= TransactionSignature.SIGHASH_ALL;\n        }\n        if (signOutputs === \"none\") {\n          signatureScope |= TransactionSignature.SIGHASH_NONE;\n        }\n        if (signOutputs === \"single\") {\n          signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n        }\n        if (anyoneCanPay) {\n          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n        }\n\n        const input = tx.inputs[inputIndex];\n\n        const otherInputs = tx.inputs.filter(\n          (_, index) => index !== inputIndex\n        );\n\n        const sourceTXID = input.sourceTXID\n          ? input.sourceTXID\n          : input.sourceTransaction?.id(\"hex\");\n        if (!sourceTXID) {\n          throw new Error(\n            \"The input sourceTXID or sourceTransaction is required for transaction signing.\"\n          );\n        }\n        sourceSatoshis ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n        if (!sourceSatoshis) {\n          throw new Error(\n            \"The sourceSatoshis or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n        lockingScript ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex]\n            .lockingScript;\n        if (!lockingScript) {\n          throw new Error(\n            \"The lockingScript or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n\n        const preimage = TransactionSignature.format({\n          sourceTXID,\n          sourceOutputIndex: input.sourceOutputIndex,\n          sourceSatoshis,\n          transactionVersion: tx.version,\n          otherInputs,\n          inputIndex,\n          outputs: tx.outputs,\n          inputSequence: input.sequence || 0xffffffff,\n          subscript: lockingScript,\n          lockTime: tx.lockTime,\n          scope: signatureScope,\n        });\n        const rawSignature = approverPrivateKey.sign(Hash.sha256(preimage));\n        const sig = new TransactionSignature(\n          rawSignature.r,\n          rawSignature.s,\n          signatureScope\n        );\n        const unlockScript = new UnlockingScript();\n        unlockScript.writeBin(sig.toChecksigFormat());\n        unlockScript.writeScript(userSigScript);\n        return unlockScript;\n      },\n      estimateLength: async () => {\n        // public key (1+33) + signature (1+73) + approver signature (1+73)\n        // Note: We add 1 to each element's length because of the associated OP_PUSH\n        return 182;\n      },\n    };\n  }\n}\n","import {\n  BroadcastFailure,\n  BroadcastResponse,\n  Hash,\n  P2PKH,\n  PrivateKey,\n  PublicKey,\n  Script,\n  Transaction,\n  TransactionSignature,\n  UnlockingScript,\n  Utils,\n} from '@bsv/sdk';\nimport {\n  GetSignatures,\n  MNEEBalance,\n  MNEEConfig,\n  MneeInscription,\n  MNEEOperation,\n  MNEEUtxo,\n  SendMNEE,\n  SignatureRequest,\n  SignatureResponse,\n} from './mnee.types.js';\nimport CosignTemplate from './mneeCosignTemplate.js';\nimport * as jsOneSat from 'js-1sat-ord';\nimport { parseCosignerScripts, parseInscription } from './utils/helper.js';\n\nexport class MNEEService {\n  private MNEE_TOKEN_ID = 'ae59f3b898ec61acbdb6cc7a245fabeded0c094bf046f35206a3aec60ef88127_0'; // prod mnee token\n  private MNEE_COSIGNER_PROD = '020a177d6a5e6f3a8689acd2e313bd1cf0dcf5a243d1cc67b7218602aee9e04b2f'; // prod cosigner\n  private MNEE_DECIMALS = 5;\n  private mneeApiToken = '92982ec1c0975f31979da515d46bae9f';\n  private mneeApi = 'https://proxy-api.mnee.net';\n  private gorillaPoolApi = 'https://ordinals.1sat.app';\n\n  constructor(apiToken?: string) {\n    if (apiToken) this.mneeApiToken = apiToken;\n  }\n\n  public async getConfig(): Promise<MNEEConfig | undefined> {\n    try {\n      const response = await fetch(`${this.mneeApi}/v1/config?auth_token=${this.mneeApiToken}`, { method: 'GET' });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const data: MNEEConfig = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch config:', error);\n      return undefined;\n    }\n  }\n\n  public toAtomicAmount(amount: number): number {\n    return Math.round(amount * 10 ** this.MNEE_DECIMALS);\n  }\n\n  private async createInscription(recipient: string, amount: number, config: MNEEConfig) {\n    const inscriptionData = {\n      p: 'bsv-20',\n      op: 'transfer',\n      id: config.tokenId,\n      amt: amount.toString(),\n    };\n    return {\n      lockingScript: jsOneSat.applyInscription(\n        new CosignTemplate().lock(recipient, PublicKey.fromString(config.approver)),\n        {\n          dataB64: Buffer.from(JSON.stringify(inscriptionData)).toString('base64'),\n          contentType: 'application/bsv-20',\n        },\n      ),\n      satoshis: 1,\n    };\n  }\n\n  private async getUtxos(address: string, ops: MNEEOperation[] = ['transfer', 'deploy+mint']): Promise<MNEEUtxo[]> {\n    try {\n      const response = await fetch(`${this.mneeApi}/v1/utxos?auth_token=${this.mneeApiToken}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify([address]),\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const data: MNEEUtxo[] = await response.json();\n      if (ops.length) {\n        return data.filter((utxo) =>\n          ops.includes(utxo.data.bsv21.op.toLowerCase() as 'transfer' | 'burn' | 'deploy+mint'),\n        );\n      }\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch UTXOs:', error);\n      return [];\n    }\n  }\n\n  private async broadcast(tx: Transaction): Promise<BroadcastResponse | BroadcastFailure> {\n    const url = `${this.gorillaPoolApi}/v5/tx`;\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/octet-stream' },\n        body: Buffer.from(tx.toBinary()),\n      });\n      const body = await response.json();\n      if (!response.ok) {\n        return {\n          status: 'error',\n          code: response.status.toString(),\n          description: body.error || 'Unknown error',\n        } as BroadcastFailure;\n      }\n      return {\n        status: 'success',\n        txid: body.txid,\n        message: 'Transaction broadcast successfully',\n      } as BroadcastResponse;\n    } catch (error) {\n      console.error('Failed to broadcast:', error);\n      return {\n        status: 'error',\n        code: 'UNKNOWN',\n        description: error instanceof Error ? error.message : 'Unknown error',\n      } as BroadcastFailure;\n    }\n  }\n\n  private async fetchBeef(txid: string): Promise<Transaction> {\n    const resp = await fetch(`${this.gorillaPoolApi}/v5/tx/${txid}/beef`);\n    if (resp.status === 404) throw new Error('Transaction not found');\n    if (resp.status !== 200) {\n      throw new Error(`${resp.status} - Failed to fetch beef for tx ${txid}`);\n    }\n    const beef = [...Buffer.from(await resp.arrayBuffer())];\n    return Transaction.fromAtomicBEEF(beef);\n  }\n\n  private async getSignatures(\n    request: GetSignatures,\n    privateKey: PrivateKey,\n  ): Promise<{\n    sigResponses?: SignatureResponse[];\n    error?: { message: string; cause?: any };\n  }> {\n    try {\n      const DEFAULT_SIGHASH_TYPE = 65;\n      let tx: Transaction;\n      switch (request.format) {\n        case 'beef':\n          tx = Transaction.fromHexBEEF(request.rawtx);\n          break;\n        case 'ef':\n          tx = Transaction.fromHexEF(request.rawtx);\n          break;\n        default:\n          tx = Transaction.fromHex(request.rawtx);\n          break;\n      }\n      const sigResponses: SignatureResponse[] = request.sigRequests.flatMap((sigReq: SignatureRequest) => {\n        return [privateKey].map((privKey: PrivateKey) => {\n          const preimage = TransactionSignature.format({\n            sourceTXID: sigReq.prevTxid,\n            sourceOutputIndex: sigReq.outputIndex,\n            sourceSatoshis: sigReq.satoshis,\n            transactionVersion: tx.version,\n            otherInputs: tx.inputs.filter((_, index) => index !== sigReq.inputIndex),\n            inputIndex: sigReq.inputIndex,\n            outputs: tx.outputs,\n            inputSequence: tx.inputs[sigReq.inputIndex].sequence || 0,\n            subscript: sigReq.script\n              ? Script.fromHex(sigReq.script)\n              : new P2PKH().lock(privKey.toPublicKey().toAddress()),\n            lockTime: tx.lockTime,\n            scope: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n          });\n          const rawSignature = privKey.sign(Hash.sha256(preimage));\n          const sig = new TransactionSignature(\n            rawSignature.r,\n            rawSignature.s,\n            sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n          );\n          return {\n            sig: Utils.toHex(sig.toChecksigFormat()),\n            pubKey: privKey.toPublicKey().toString(),\n            inputIndex: sigReq.inputIndex,\n            sigHashType: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n            csIdx: sigReq.csIdx,\n          };\n        });\n      });\n      return Promise.resolve({ sigResponses });\n    } catch (err: any) {\n      console.error('getSignatures error', err);\n      return {\n        error: {\n          message: err.message ?? 'unknown',\n          cause: err.cause,\n        },\n      };\n    }\n  }\n\n  public async transfer(request: SendMNEE[], wif: string): Promise<{ txid?: string; rawtx?: string; error?: string }> {\n    try {\n      const config = await this.getConfig();\n      if (!config) throw new Error('Config not fetched');\n\n      const totalAmount = request.reduce((sum, req) => sum + req.amount, 0);\n      if (totalAmount <= 0) return { error: 'Invalid amount' };\n      const totalAtomicTokenAmount = this.toAtomicAmount(totalAmount);\n\n      const privateKey = PrivateKey.fromWif(wif);\n      const address = privateKey.toAddress();\n      const utxos = await this.getUtxos(address);\n      const totalUtxoAmount = utxos.reduce((sum, utxo) => sum + (utxo.data.bsv21.amt || 0), 0);\n      if (totalUtxoAmount < totalAtomicTokenAmount) {\n        return { error: 'Insufficient MNEE balance' };\n      }\n\n      const fee =\n        request.find((req) => req.address === config.burnAddress) !== undefined\n          ? 0\n          : config.fees.find(\n              (fee: { min: number; max: number }) =>\n                totalAtomicTokenAmount >= fee.min && totalAtomicTokenAmount <= fee.max,\n            )?.fee;\n      if (fee === undefined) return { error: 'Fee ranges inadequate' };\n\n      const tx = new Transaction(1, [], [], 0);\n      let tokensIn = 0;\n      const signingAddresses: string[] = [];\n      let changeAddress = '';\n\n      while (tokensIn < totalAtomicTokenAmount + fee) {\n        const utxo = utxos.shift();\n        if (!utxo) return { error: 'Insufficient MNEE balance' };\n\n        const sourceTransaction = await this.fetchBeef(utxo.txid);\n        if (!sourceTransaction) return { error: 'Failed to fetch source transaction' };\n\n        signingAddresses.push(utxo.owners[0]);\n        changeAddress = changeAddress || utxo.owners[0];\n        tx.addInput({\n          sourceTXID: utxo.txid,\n          sourceOutputIndex: utxo.vout,\n          sourceTransaction,\n          unlockingScript: new UnlockingScript(),\n        });\n        tokensIn += utxo.data.bsv21.amt;\n      }\n\n      for (const req of request) {\n        tx.addOutput(await this.createInscription(req.address, this.toAtomicAmount(req.amount), config));\n      }\n      if (fee > 0) tx.addOutput(await this.createInscription(config.feeAddress, fee, config));\n\n      const change = tokensIn - totalAtomicTokenAmount - fee;\n      if (change > 0) {\n        tx.addOutput(await this.createInscription(changeAddress, change, config));\n      }\n\n      const sigRequests: SignatureRequest[] = tx.inputs.map((input, index) => {\n        if (!input.sourceTXID) throw new Error('Source TXID is undefined');\n        return {\n          prevTxid: input.sourceTXID,\n          outputIndex: input.sourceOutputIndex,\n          inputIndex: index,\n          address: signingAddresses[index],\n          script: input.sourceTransaction?.outputs[input.sourceOutputIndex].lockingScript.toHex(),\n          satoshis: input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis || 1,\n          sigHashType:\n            TransactionSignature.SIGHASH_ALL |\n            TransactionSignature.SIGHASH_ANYONECANPAY |\n            TransactionSignature.SIGHASH_FORKID,\n        };\n      });\n\n      const rawtx = tx.toHex();\n      const res = await this.getSignatures({ rawtx, sigRequests }, privateKey);\n      if (!res?.sigResponses) return { error: 'Failed to get signatures' };\n\n      for (const sigResponse of res.sigResponses) {\n        tx.inputs[sigResponse.inputIndex].unlockingScript = new Script()\n          .writeBin(Utils.toArray(sigResponse.sig, 'hex'))\n          .writeBin(Utils.toArray(sigResponse.pubKey, 'hex'));\n      }\n\n      const base64Tx = Utils.toBase64(tx.toBinary());\n      const response = await fetch(`${this.mneeApi}/v1/transfer?auth_token=${this.mneeApiToken}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ rawtx: base64Tx }),\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const { rawtx: responseRawtx } = await response.json();\n      if (!responseRawtx) return { error: 'Failed to broadcast transaction' };\n\n      const decodedBase64AsBinary = Utils.toArray(responseRawtx, 'base64');\n      const tx2 = Transaction.fromBinary(decodedBase64AsBinary);\n      await this.broadcast(tx2);\n\n      return { txid: tx2.id('hex'), rawtx: Utils.toHex(decodedBase64AsBinary) };\n    } catch (error) {\n      let errorMessage = 'Transaction submission failed';\n      if (error instanceof Error) {\n        errorMessage = error.message;\n        if (error.message.includes('HTTP error')) {\n          // Add more specific error handling if needed based on response status\n          console.error('HTTP error details:', error);\n        }\n      }\n      console.error('Failed to transfer tokens:', errorMessage);\n      return { error: errorMessage };\n    }\n  }\n\n  public async getBalance(address: string): Promise<MNEEBalance> {\n    try {\n      const config = await this.getConfig();\n      if (!config) throw new Error('Config not fetched');\n      const res = await this.getUtxos(address);\n      const balance = res.reduce((acc, utxo) => {\n        if (utxo.data.bsv21.op === 'transfer') {\n          acc += utxo.data.bsv21.amt;\n        }\n        return acc;\n      }, 0);\n\n      const decimalAmount = parseFloat((balance / 10 ** (config.decimals || 0)).toFixed(config.decimals));\n      return { amount: balance, decimalAmount };\n    } catch (error) {\n      console.error('Failed to fetch balance:', error);\n      return { amount: 0, decimalAmount: 0 };\n    }\n  }\n\n  public async validateMneeTx(rawTx: string, request?: SendMNEE[]) {\n    try {\n      const tx = Transaction.fromHex(rawTx);\n      const scripts = tx.outputs.map((output) => output.lockingScript);\n      const parsedScripts = parseCosignerScripts(scripts);\n\n      if (!request) {\n        parsedScripts.forEach((parsed) => {\n          if (parsed && parsed.cosigner !== this.MNEE_COSIGNER_PROD) {\n            throw new Error(`Invalid cosigner: ${parsed.cosigner}`);\n          }\n        });\n      } else {\n        request.forEach((req, idx) => {\n          const { address, amount } = req;\n          const cosigner = parsedScripts.find((parsed) => parsed?.cosigner === this.MNEE_COSIGNER_PROD);\n          if (!cosigner) {\n            throw new Error(`Cosigner not found for address: ${address} at index: ${idx}`);\n          }\n\n          const addressFromScript = parsedScripts.find((parsed) => parsed?.address === address);\n          if (!addressFromScript) {\n            throw new Error(`Address not found in script for address: ${address} at index: ${idx}`);\n          }\n          const script = tx.outputs[idx].lockingScript;\n          const inscription = parseInscription(script);\n          const content = inscription?.file?.content;\n          if (!content) throw new Error('Invalid inscription content');\n          const inscriptionData = Utils.toUTF8(content);\n          if (!inscriptionData) throw new Error('Invalid inscription content');\n          const inscriptionJson: MneeInscription = JSON.parse(inscriptionData);\n          if (inscriptionJson.p !== 'bsv-20') throw new Error(`Invalid bsv 20 protocol: ${inscriptionJson.p}`);\n          if (inscriptionJson.op !== 'transfer') throw new Error(`Invalid operation: ${inscriptionJson.op}`);\n          if (inscriptionJson.id !== this.MNEE_TOKEN_ID) throw new Error(`Invalid token id: ${inscriptionJson.id}`);\n          if (inscriptionJson.amt !== Math.round(amount * 10 ** this.MNEE_DECIMALS).toString()) {\n            throw new Error(`Invalid amount: ${inscriptionJson.amt}`);\n          }\n        });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(error);\n      return false;\n    }\n  }\n}\n","import { Hash, OP, Script, Utils } from '@bsv/sdk';\nimport { Inscription, ParsedCosigner } from '../mnee.types';\n\nexport const parseInscription = (script: Script) => {\n  let fromPos: number | undefined;\n  for (let i = 0; i < script.chunks.length; i++) {\n    const chunk = script.chunks[i];\n    if (\n      i >= 2 &&\n      chunk.data?.length === 3 &&\n      Utils.toUTF8(chunk.data) == 'ord' &&\n      script.chunks[i - 1].op == OP.OP_IF &&\n      script.chunks[i - 2].op == OP.OP_FALSE\n    ) {\n      fromPos = i + 1;\n    }\n  }\n  if (fromPos === undefined) return;\n\n  const insc = {\n    file: { hash: '', size: 0, type: '' },\n    fields: {},\n  } as Inscription;\n\n  for (let i = fromPos; i < script.chunks.length; i += 2) {\n    const field = script.chunks[i];\n    if (field.op == OP.OP_ENDIF) {\n      break;\n    }\n    if (field.op > OP.OP_16) return;\n    const value = script.chunks[i + 1];\n    if (value.op > OP.OP_PUSHDATA4) return;\n\n    if (field.data?.length) continue;\n\n    let fieldNo = 0;\n    if (field.op > OP.OP_PUSHDATA4 && field.op <= OP.OP_16) {\n      fieldNo = field.op - 80;\n    } else if (field.data?.length) {\n      fieldNo = field.data[0];\n    }\n    switch (fieldNo) {\n      case 0:\n        insc.file!.size = value.data?.length || 0;\n        if (!value.data?.length) break;\n        insc.file!.hash = Utils.toBase64(Hash.sha256(value.data));\n        insc.file!.content = value.data;\n        break;\n      case 1:\n        insc.file!.type = Buffer.from(value.data || []).toString();\n        break;\n    }\n  }\n\n  return insc;\n};\n\nexport const parseCosignerScripts = (scripts: any): ParsedCosigner[] => {\n  return scripts.map((script: any) => {\n    const chunks = script.chunks;\n    for (let i = 0; i <= chunks.length - 6; i++) {\n      if (\n        chunks[0 + i].op === OP.OP_DUP &&\n        chunks[1 + i].op === OP.OP_HASH160 &&\n        chunks[2 + i].data?.length === 20 &&\n        chunks[3 + i].op === OP.OP_EQUALVERIFY &&\n        chunks[4 + i].op === OP.OP_CHECKSIGVERIFY &&\n        chunks[5 + i].data?.length === 33 &&\n        chunks[6 + i].op === OP.OP_CHECKSIG\n      ) {\n        return {\n          cosigner: Utils.toHex(chunks[5 + i].data || []),\n          address: Utils.toBase58Check(chunks[2 + i].data || [], [0]),\n        };\n      }\n    }\n  });\n};\n","import { MNEEService } from './mneeService.js';\nimport { MNEEBalance, MNEEConfig, SendMNEE, TransferResponse } from './mnee.types.js';\nexport * from './mnee.types.js';\n\nexport interface MneeInterface {\n  config(): Promise<MNEEConfig | undefined>;\n  balance(address: string): Promise<MNEEBalance>;\n  validateMneeTx(rawtx: string, request?: SendMNEE[]): Promise<boolean>;\n  transfer(request: SendMNEE[], wif: string): Promise<TransferResponse>;\n  toAtomicAmount(amount: number, decimals: number): number;\n}\n\n/**\n * Represents the Mnee class that provides methods to interact with the MNEE service.\n */\nexport default class Mnee implements MneeInterface {\n  private service: MNEEService;\n\n  constructor(apiToken?: string) {\n    this.service = new MNEEService(apiToken);\n  }\n\n  /**\n   * Validates an MNEE transaction.\n   *\n   * @param rawtx - The raw transaction to validate.\n   * @param request - An array of SendMNEE objects representing the transfer details. Use this parameter to validate the transaction against the specified transfer details. If it is not provided, it will only validate that the transaction is well-formed with the cosigner.\n   * @returns A promise that resolves to a boolean indicating whether the transaction is valid.\n   */\n  async validateMneeTx(rawtx: string, request?: SendMNEE[]): Promise<boolean> {\n    return this.service.validateMneeTx(rawtx, request);\n  }\n\n  /**\n   * Converts a given amount to its atomic representation based on the specified number.\n   *\n   * @param amount - The amount to be converted.\n   * @returns The atomic representation of the given amount.\n   *\n   * @example\n   * ```typescript\n   * toAtomicAmount(1.5); // 150000\n   * ```\n   */\n  toAtomicAmount(amount: number): number {\n    return this.service.toAtomicAmount(amount);\n  }\n\n  /**\n   * Retrieves the configuration for the MNEE service.\n   *\n   * @returns {Promise<MNEEConfig | undefined>} A promise that resolves to the MNEE configuration object,\n   * or undefined if the configuration could not be retrieved.\n   */\n  async config(): Promise<MNEEConfig | undefined> {\n    return this.service.getConfig();\n  }\n\n  /**\n   * Retrieves the balance for a given address.\n   *\n   * @param address - The address to retrieve the balance for.\n   * @returns A promise that resolves to an MNEEBalance object containing the balance information.\n   */\n  async balance(address: string): Promise<MNEEBalance> {\n    return this.service.getBalance(address);\n  }\n\n  /**\n   * Transfers the specified MNEE tokens using the provided WIF (Wallet Import Format) key.\n   *\n   * @param {SendMNEE[]} request - An array of SendMNEE objects representing the transfer details.\n   * @param {string} wif - The Wallet Import Format key used to authorize the transfer.\n   * @returns {Promise<TransferResponse>} A promise that resolves to a TransferResponse object containing the result of the transfer.\n   */\n  async transfer(request: SendMNEE[], wif: string): Promise<TransferResponse> {\n    return this.service.transfer(request, wif);\n  }\n}\n"],"names":["CosignTemplate","lock","userPKHash","approverPubKey","pkhash","hash","Utils","fromBase58Check","prefix","Error","data","lockingScript","LockingScript","writeOpCode","OP","OP_DUP","OP_HASH160","writeBin","OP_EQUALVERIFY","OP_CHECKSIGVERIFY","encode","OP_CHECKSIG","userUnlock","userPrivateKey","signOutputs","anyoneCanPay","sourceSatoshis","sign","async","tx","inputIndex","_input$sourceTransact","_input$sourceTransact2","_input$sourceTransact3","signatureScope","TransactionSignature","SIGHASH_FORKID","SIGHASH_ALL","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","input","inputs","otherInputs","filter","_","index","sourceTXID","sourceTransaction","id","outputs","sourceOutputIndex","satoshis","preimage","format","transactionVersion","version","inputSequence","sequence","subscript","lockTime","scope","rawSignature","Hash","sha256","sig","r","s","unlockScript","UnlockingScript","toChecksigFormat","toPublicKey","estimateLength","unlock","approverPrivateKey","userSigScript","_input$sourceTransact4","_input$sourceTransact5","_input$sourceTransact6","writeScript","MNEEService","constructor","apiToken","this","MNEE_TOKEN_ID","MNEE_COSIGNER_PROD","MNEE_DECIMALS","mneeApiToken","mneeApi","gorillaPoolApi","getConfig","response","fetch","method","ok","status","json","error","console","toAtomicAmount","amount","Math","round","createInscription","recipient","config","inscriptionData","p","op","tokenId","amt","toString","jsOneSat","applyInscription","PublicKey","fromString","approver","dataB64","Buffer","from","JSON","stringify","contentType","getUtxos","address","ops","headers","body","length","utxo","includes","bsv21","toLowerCase","broadcast","url","toBinary","txid","message","code","description","fetchBeef","resp","beef","arrayBuffer","Transaction","fromAtomicBEEF","getSignatures","request","privateKey","DEFAULT_SIGHASH_TYPE","fromHexBEEF","rawtx","fromHexEF","fromHex","sigResponses","sigRequests","flatMap","sigReq","map","privKey","prevTxid","outputIndex","script","Script","P2PKH","toAddress","sigHashType","toHex","pubKey","csIdx","Promise","resolve","err","_err$message","cause","transfer","wif","_config$fees$find","totalAmount","reduce","sum","req","totalAtomicTokenAmount","PrivateKey","fromWif","utxos","fee","undefined","find","burnAddress","fees","min","max","tokensIn","signingAddresses","changeAddress","shift","push","owners","addInput","vout","unlockingScript","addOutput","feeAddress","change","res","sigResponse","toArray","base64Tx","toBase64","responseRawtx","decodedBase64AsBinary","tx2","fromBinary","errorMessage","getBalance","balance","acc","decimalAmount","parseFloat","decimals","toFixed","validateMneeTx","rawTx","parsedScripts","output","chunks","i","_chunks$data","_chunks$data2","cosigner","toBase58Check","forEach","idx","_inscription$file","parsed","inscription","_value$data","_value$data2","fromPos","_chunk$data","chunk","toUTF8","OP_IF","OP_FALSE","insc","file","size","type","fields","_field$data","_field$data2","field","OP_ENDIF","OP_16","value","OP_PUSHDATA4","fieldNo","content","parseInscription","inscriptionJson","parse","Mnee","service"],"mappings":"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"}